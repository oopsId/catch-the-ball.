<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #game {
            border: 4px solid #2c6e9d;
            border-radius: 15px;
            padding: 5px;
            touch-action: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        #parallax-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #0f0c29, #302b63, #24243e);
            background-size: 200% 200%;
            z-index: 1;
            transition: transform 0.1s ease;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<div id="parallax-bg"></div>
<canvas id="game" width="400" height="400"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const parallaxBg = document.getElementById("parallax-bg");

// Переменные для шарика
let x = canvas.width / 2, y = 50;
let ballRadius = 20;
let dx = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 4);
let dy = 4 + Math.random() * 4;

// Переменные для ракетки
let paddleWidth = 80;
let paddleHeight = 10;
let paddleX = (canvas.width - paddleWidth) / 2;

// Переменные для анимации
let time = 0;

// Функция для фрактала Мандельброта
function drawMandelbrot() {
    const width = canvas.width;
    const height = canvas.height;
    const maxIter = 100;
    const zoom = 150 + Math.sin(time * 0.01) * 20;
    const offsetX = -0.7;
    const offsetY = 0;

    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;

    for (let px = 0; px < width; px++) {
        for (let py = 0; py < height; py++) {
            const x0 = (px - width / 2) / zoom + offsetX;
            const y0 = (py - height / 2) / zoom + offsetY;
            let x = 0, y = 0;
            let iter = 0;

            while (x * x + y * y <= 4 && iter < maxIter) {
                const xtemp = x * x - y * y + x0;
                y = 2 * x * y + y0;
                x = xtemp;
                iter++;
            }

            const i = (py * width + px) * 4;
            if (iter === maxIter) {
                data[i] = 0;
                data[i + 1] = 0;
                data[i + 2] = 0;
            } else {
                const hue = (iter + Math.sin(time * 0.01) * 10) % 360;
                const saturation = 100;
                const lightness = 50 + iter % 50;
                const [r, g, b] = hslToRgb(hue, saturation, lightness);
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
            data[i + 3] = 180;
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

// Конвертация HSL в RGB
function hslToRgb(h, s, l) {
    s /= 100;
    l /= 100;
    const k = n => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
}

// Эффект пламени
function drawFlame() {
    const flamePulse = Math.sin(time * 0.05);
    if (Math.random() < 0.1) {
        const flameX = Math.random() * canvas.width;
        const flameY = canvas.height * 0.8 + Math.random() * canvas.height * 0.2;
        const gradient = ctx.createRadialGradient(flameX, flameY, 0, flameX, flameY, 30);
        gradient.addColorStop(0, `rgba(255, 150, 0, ${0.5 + flamePulse * 0.2})`);
        gradient.addColorStop(1, "rgba(255, 50, 0, 0)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(flameX, flameY, 30, 0, 2 * Math.PI);
        ctx.fill();
    }
}

// Управление ракеткой через мышь
canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    paddleX = mouseX - paddleWidth / 2;
    if (paddleX < 0) paddleX = 0;
    if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
});

// Управление ракеткой через сенсор
canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touchX = e.touches[0].clientX - rect.left;
    paddleX = touchX - paddleWidth / 2;
    if (paddleX < 0) paddleX = 0;
    if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
});

// Управление ракеткой через гироскоп
window.addEventListener("deviceorientation", (e) => {
    const beta = e.beta; // Наклон вперед-назад (в градусах)
    const gamma = e.gamma; // Наклон влево-вправо (в градусах)
    // Используем gamma для движения ракетки
    const tilt = gamma / 45; // Нормализуем угол (-1 до 1)
    paddleX = (canvas.width - paddleWidth) * (0.5 + tilt / 2); // Позиция от 0 до canvas.width - paddleWidth
    if (paddleX < 0) paddleX = 0;
    if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
});

// Параллакс-эффект
document.addEventListener("mousemove", (e) => {
    const moveX = (e.clientX - window.innerWidth / 2) * 0.02;
    const moveY = (e.clientY - window.innerHeight / 2) * 0.02;
    parallaxBg.style.transform = `translate(${moveX}px, ${moveY}px)`;
});

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Рисуем фрактал и пламя
    drawMandelbrot();
    drawFlame();
    time++;

    // Шарик с отскоками
    if (x + ballRadius > canvas.width) {
        dx *= -0.98;
        x = canvas.width - ballRadius;
    }
    if (x - ballRadius < 0) {
        dx *= -0.98;
        x = ballRadius;
    }
    if (y - ballRadius < 0) {
        dy *= -0.98;
        y = ballRadius;
    }
    if (y + ballRadius > canvas.height - paddleHeight) {
        if (x > paddleX && x < paddleX + paddleWidth) {
            dy *= -0.98;
            y = canvas.height - paddleHeight - ballRadius;
            dx += (x - (paddleX + paddleWidth / 2)) * 0.02;
        } else if (y + ballRadius > canvas.height) {
            x = canvas.width / 2;
            y = 50;
            dx = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 4);
            dy = 4 + Math.random() * 4;
        }
    }
    x += dx;
    y += dy;

    // Рисуем ракетку
    ctx.fillStyle = "#2c6e9d";
    ctx.fillRect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);

    // Рисуем шарик
    ctx.fillStyle = (y + ballRadius > canvas.height - paddleHeight && x > paddleX && x < paddleX + paddleWidth) ? "#ff6b6b" : "#ff0000";
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, 2 * Math.PI);
    ctx.fill();

    requestAnimationFrame(draw);
}

// Инициализация Telegram Web App
window.Telegram.WebApp.ready();
window.Telegram.WebApp.expand();

// Запрос разрешения на доступ к гироскопу (для iOS)
if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission()
        .then(permissionState => {
            if (permissionState === 'granted') {
                console.log("Гироскоп разрешён");
            } else {
                console.log("Гироскоп не разрешён");
            }
        })
        .catch(console.error);
}

draw();
</script>
</body>
</html>
